<center>
<h1>L2 - Module</h1>
<h3>UnitConverter</h3>
</center>

### Description
This module will convert between the metric and imperial unit systems and temperature conversions between Kelvin, Celsius, and Fahrenheit.

### Domain Model
![Domain model](images/Domain-Model.png)

# Reflection

Reading up on the npm modules took some time and I had a hard time getting it all to work. I set it up a CI on github actions that will transpile and upload the module to the npm repository on every push if it passes.

It is not a very difficult project per se, but it is a lot of code to write and in some parts github copilot has been helpful but most of the time it has been good old fashion copy & paste that did the trick.

The following automated tests where set up and run.
[Test Run](./test.log.md)

## Meaningful Names

| Name | Explanation | Reflection and rules from CC |
|:-----|:--------------|:------------------------------|
| **UnitConverter** | The main object that is the access point to the functionality| The name is short and actually says what it is about. It's a noun and it adheres to the following rules: **Use Intention-Revealing Names**, **Use Pronounceable Names**, and **Avoid Disinformation**
| **MetricToImperial** | Class handling metric to imperial conversions | The name reveals quite well what you can expect from the class and it adheres to the **Pronounceable Names** and maybe even more **Don't be Cute** and **Add meaningful Context** |
|**ImperialToMetric** | Class that is handling imperial to metric conversions | Also adheres well to **Add Meaningful Context**, **Intention-Revealing Names**, and **Avoid Disinformation** |
| **TemperatureConverter** | The class that handles the conversions between Celsius, Fahrenheit, and Kelvin | Also this name is quite clear about what you can expect from this class. It adheres to **Searchable Names** as well as **Solution Domain Names** and the **Class Names** rule since it is a noun phrase. |
| **convert** | convert is the main entry-point into each of the above three classes that handles conversions. | It's a verb as it is a function so it adheres to **Method Names** its functionality also adheres to the **Single Responsibility Principle** even if that comes later in the book and it **Avoids Encoding** |

The content in chapter two as in the whole book itself is quite old by now. But it is a good reference book when it comes to writing good and clean code. Much of the content feels quite obvious like names that reveal the intention of the class or that says what the method is actually doing. I learned a while back that you should name all your variables and classes so that you don't have to add any comments. While I think it is a good practice in general I can also see the usefulness of some comments. Unfortunately we were forced to write comments on everything in earlier JavaScript courses and using the same linting rules here produces a lot of comments that I personally think is redundant.

We can conclude that the capabilities of IDEs have advanced since 2009 and now provide much more information, referring to the comments on Eclipse and IntelliJ that was mentioned in Pick One Word Per Concept. "Pick One Word Per Concept" is a principle that I, and many students with me, would have appreciated if the Computer Science faculty at Linnaeus University would have adhered to too. :)

Having said all that it is still interesting and very relevant when it comes to naming conventions and how important it is to think about good names for functions and variables. It makes the development work much easier if you can read the code and it more or less tells you a story.  I just reviewed some old code from 2003, and to some extent, I'm surprised that I was already adhering to some of the teachings in this book, even though the book wasn't published until 2009. So what relevance does that have? Simply put, naming variables and methods clearly makes it easier to understand their intended functions. Properly naming variables, methods and classes is important and as code bases grow it becomes ever more important, because I think most people are like me and don't like to sit and read a long complicated description of a package to be able to use it. I believe it should be self-explanatory and names should be relevant and descriptive so you don't have to read a manual just the names in a properly organized interface. That is the thinking behind that all the operating classes i.e. MetricToImperial, ImperialToMetric, and TemperatureConverter all have one entry point the method *convert()*. I realize that there should have been some more consistency in where things were placed as arguments in that function since it differs a bit between the convert method in the TemperatureConverter and the other two classes. I should have decided on one order e.g. (numeric value, from type, to type) as in the TemperatureConverter class instead of what the other two classes that has the argument order (from type, numeric value, to type). The code also do not adhere to the DRY principle. There are a few improvements available there to do especially when it comes to the MetricToImperial class. But that will be a later concern. For now it works and the code is reasonably stable depending on how it's used. Neither does it take into account the different decimal separators, which could be an improvement in the future.

## Functions

| Method name | no. rows | Reflection |
|:------------|---------:|:-----------|
| ImperialToMetrics.convert()| 15| It's a simple function that only does selection through a switch/catch structure. It complies with **Function Names** it converts it has **No Side Effects** since it only passes control on to the next function It is also a **Triad** as it takes three arguments as does the other convert methods in the other two classes.|
| ImperialToMetrics.#mileToMetric()| 14| It's one of the private functions that does the job in this case it is as the convert method it selects the next step in a switch/catch structure that will hand the control over to the next step in the process depending on the value of the Metric1DType it receives. It also complies with the **Function Names** principle and **Command-Query Separation** |
|MetricToImperial.#meterToImperial() | 16| This is a very similar function to the one above but it operates the other way around instead. I.e. from a metric entity to selecting imperial entities. **Do One Thing** is one of the concept it doesn't adheres to as well as **Open Close Principle** as noted in the section on Switch statements. It is a **Dyadic Function**.|
|MetricToImperial.#kilometerToMile() | 3| **Do One Thing** and **Small** are two principles this function adheres to very well.|
|TemperatureConverter.convert() | 12| Another function that adheres to many of the principles such as **One Level of Abstraction** and **Reading Code from Top to Bottom**. As is evident **Switch Statements** are not mr. Martin's favorites 

Just realized that I have commented on this above to some extent. But that doesn't mean that we can't continue with functions or methods here. I just remembered something that I read many moons ago. Can't remember where I got this from but at some point in time I think that people defined functions as methods that returned some value of some sort and if it didn't it was called a method. I might remember wrong but somewhere in the back of my mind there is a memory of something like that.

Chapter three seems to be mostly focusing on getting into the absurdities of limiting what functions can do. In the sense that a descriptive name and functions that are focused on one main concern is something that I can appreciate I'm not thrilled about the idea of long winding series of functions calling functions calling function calling functions etc. etc. without any of them really doing something useful. I've seen code like that and it just makes me tired and irritated. Like the section on error handling. I can understand the thinking but I don't necessarily share the view. Personally I prefer to encapsulate functionalities inside a try/catch block and I don't think that it is disturbing at all. I you have such a large function/method that it becomes difficult to keep track of your error boundaries with a try/catch block then you have bigger problem than the error handling to sort out. To try to minimize what a function does so that its name becomes relevant and reveal its intention is a good thing and should be kept in mind, but if that is done properly then there shouldn't be any need to break out any try/catch block. Ideally there should only be one try/catch block in your function encapsulating if not all then at least the potential problematic areas of the code i.e. code that can cause problems such as read/write operations, all different communication connections to databases, applications or APIs. 

Not really agreeing with everything that Mr. Martin says I must say I totally agree with and support the idea of DRY. It's inefficient and a waste of time to write the same code over and over again. Like he says, ever since the invention of the subroutine there has been an ongoing attempt to eliminate duplicate code.

When it comes to function arguments I agree with that it is good to keep that to a minimum. However, ideas like we shouldn't use Singleton patterns or any form of global variables works against this principle. Personally, I don't have an issue with using Singleton patterns or other global variables or objects if it's done purposefully and not misused. There are many instances where such objects are very practical and you can avoid sending an object down several layers of code, especially if you would implement the principle of small functions, sending an argument to a function that it is not going to use but merely pass on to another function and so on is in my view a very poor way of passing information around to those functions that need it. I like React's model of context where a provider gives, within its boundaries, access to values without having to pass them along as arguments/props. This is a form of global variables and it makes the code so much easier to maintain and understand than to try and follow a specific value on its journey through many layers of functions. But, as with everything else it needs to be done wisely and not abuse it just as you shouldn't abuse the small function principle of a function can only do one thing. Keeping that as an ideal is good but it's not the Bible and it's not carved in stone.

When it comes to the section on Error Codes I see things the same way. I've never been a fan of returning error codes instead I prefer an event driven model for errors in combination with try/catch blocks to catch them in. In this case I am using TypeScript to help with type checking which will also make it easier for others using the code to provide the right type of values for the respective arguments in the  convert() method of each class.

## Conclusion
There are many valuable principles presented albeit somewhat obvious and self-evident in some cases. I am then thinking about things like **Intention-Revealing Names**, **Avoid Disinformation**, **Pronounceable Names**, and **Descriptive Names** in functions. 
Looking at the code I realize that some names like _TemperatureTypes_ probably should have been _TemperatureUnits_ or _TemperatureScales_ that would better have conveyed their purpose and content. Then there is probably a lot to be done to live up to the DRY principle which is something that especially the _MetricToImperial_ class could benefit from, but also the others with the exception of the TemperatureConverter class where I think I managed that better. I've tried to  implement the **First Rule of Functions** i.e. that they should be small and **Do One Thing** which obviously Mr. Martin don't agree with me because I see even switch selections as doing one thing which he clearly don't, but I can live with that.

On a final note I think it would have been beneficial if we could have had a short introduction on how to write npm modules and deploying them to npmjs.org. I know it's not a part of this course's curriculum but it would nevertheless have been useful.
Also, even if that isn't part of this course either, a quick guide in writing YAML files especially for use in github actions and gitlab pipelines.